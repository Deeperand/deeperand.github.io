

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/fig/avatar.jpg">
  <link rel="icon" href="/fig/avatar.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="
本文于去年 C 语言期末复习期间所写, 于 6 月 19 日首发于知乎, 主要回顾了 C 语言的基本语法.
">
  <meta name="author" content="Deeperand">
  <meta name="keywords" content="">
  
  <title>C 语言基本语法复习 - Blog | Deeperand</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/a11y-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"deeperand.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"rUWOyfnPKrha74U4qmAX3upx-gzGzoHsz","app_key":"ip7rFU6LO69hBFLUoU0cCJMd","server_url":"https://ruwoyfnp.lc-cn-n1-shared.com"}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Deeplog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/fig/blackhole.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C 语言基本语法复习">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Deeperand
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-30 10:04" pubdate>
        2021.05.30, 10:04
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      60
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C 语言基本语法复习</h1>
            
              <p class="note note-info">
                
                  最后更新：2021.11.09, 10:41
                
              </p>
            
            <div class="markdown-body">
              <blockquote>
<p>本文于去年 C 语言期末复习期间所写, 于 6 月 19 日首发于<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149419779">知乎</a>, 主要回顾了 C 语言的基本语法.</p>
</blockquote>
<span id="more"></span>
<h2 id="1-C-程序设计初步"><a href="#1-C-程序设计初步" class="headerlink" title="1 C 程序设计初步"></a>1 C 程序设计初步</h2><h3 id="C-程序结构和处理过程"><a href="#C-程序结构和处理过程" class="headerlink" title="C 程序结构和处理过程"></a>C 程序结构和处理过程</h3><p>&emsp;&emsp;基本程序结构包括预编译语句, 主函数, 自定义函数等.</p>
<p>&emsp;&emsp;基本处理过程可以分为源代码编写, 程序的编译, 程序的连接, 运行与调试这几个过程.</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>&emsp;&emsp;常用的有:</p>
<ol>
<li>整型: <code>int</code>, <code>long</code></li>
<li>实型: <code>float</code>, <code>double</code></li>
<li>字符型: <code>char</code></li>
</ol>
<h3 id="标准输入-输出"><a href="#标准输入-输出" class="headerlink" title="标准输入/输出"></a>标准输入/输出</h3><ol>
<li>可以通过 <code>scanf()</code> 与 <code>printf()</code> 来输入及输出数据;</li>
<li>对于字符, 还可使用 <code>getchar()</code> 与 <code>putchar()</code> 来输入及输出数据;</li>
<li>对于字符串, 还可以使用 <code>gets()</code> 与 <code>puts()</code> 来输入及输出字符;</li>
</ol>
<h2 id="2-预编译处理及元编程基础"><a href="#2-预编译处理及元编程基础" class="headerlink" title="2 预编译处理及元编程基础"></a>2 预编译处理及元编程基础</h2><p>&emsp;&emsp;预处理本质上可视为字符串的替换, 亦即可以等效认为编译时先将源代码依据预处理命令进行一定的字符替换 (不妨称为<strong>宏展开</strong>), 再将经过字符替换后的源代码进行编译.</p>
<h3 id="宏定义预处理命令"><a href="#宏定义预处理命令" class="headerlink" title="宏定义预处理命令"></a>宏定义预处理命令</h3><h4 id="不带参数的宏"><a href="#不带参数的宏" class="headerlink" title="不带参数的宏"></a>不带参数的宏</h4><p>&emsp;&emsp;宏定义的一般语法为:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> <span class="hljs-meta-string">&lt;str1&gt;</span> <span class="hljs-meta-string">&lt;str2&gt;</span></span><br></code></pre></div></td></tr></table></figure>
<p>预处理时将所有处于变量位置的字符 <code>&lt;str1&gt;</code> 替换为 <code>&lt;str2&gt;</code>.</p>
<p>&emsp;&emsp;初学者常犯的一个错误是边替换边计算. 例如对于:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M N+2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NM 2*M</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = MN;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %d\n&quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>正确的理解是 <code>MN</code> -&gt; <code>2*M</code>, 随后进行 <code>M</code> -&gt; <code>N+2</code>, 再进行 <code>N</code> -&gt; <code>2</code>, 因此输出为 6. (不能理解为先将 <code>M</code> 与 <code>N</code> 进行替换再相乘!)</p>
<h4 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h4><p>&emsp;&emsp;带参数宏的基本语法为:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> <span class="hljs-meta-string">&lt;str1&gt;</span>(<span class="hljs-meta-string">&lt;parameter&gt;</span>) <span class="hljs-meta-string">&lt;str2&gt;</span></span><br></code></pre></div></td></tr></table></figure>
<p>如若存在带参宏定定义:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI 3.14</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S(r) PI*r*r</span><br></code></pre></div></td></tr></table></figure>
<p>则后续程序中若存在 <code>S(a)</code> 则将展开为 <code>PI*a*a</code>, 若存在 <code>S(a+b)</code> 则将展开为 <code>PI*a+b*a+b</code>. 初学者容易误将 <code>a+b</code> 视为带括号的, 从而认为后者的展开是 <code>PI*(a+b)*(a+b)</code>, 但这是不正确的 (要得到这样的效果应该输入 <code>SP\((a+b))</code>).</p>
<h3 id="文件包含预处理命令"><a href="#文件包含预处理命令" class="headerlink" title="文件包含预处理命令"></a>文件包含预处理命令</h3><p>&emsp;&emsp;以下两种方法均可以实现文件包含:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;file&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;file&quot;</span></span><br></code></pre></div></td></tr></table></figure>
<p>差别在于:</p>
<ol>
<li>尖括号: 编译系统按照系统设定的标准目录搜索被包含的文件</li>
<li>双引号: 按照文件全名重点指定路径搜索; 若未找到文件, 再按相对目录搜索; 若仍未找到文件, 最后搜索其它目录.</li>
</ol>
<h3 id="条件编译预处理命令"><a href="#条件编译预处理命令" class="headerlink" title="条件编译预处理命令"></a>条件编译预处理命令</h3><p>&emsp;&emsp;条件包含预处理的基本语法为:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> <span class="hljs-meta-string">&lt;cond_1&gt;</span></span><br>    &lt;code_1&gt;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> <span class="hljs-meta-string">&lt;cond_2&gt;</span></span><br>    &lt;code_2&gt;<br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    &lt;default_code&gt;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<p>条件编译语句会根据条件 <code>&lt;cond&gt;</code> 是否成立来选择编译时实际采用哪种代码.</p>
<p>&emsp;&emsp;另一种方便的条件编译是判断变量是否定义:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> <span class="hljs-meta-string">&lt;symbol&gt;</span></span><br>    &lt;code_1&gt;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    &lt;code_2&gt;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<p>这里 <code>&lt;symbol&gt;</code> 是一个标识符. 但标识符已经被定义时采用 <code>&lt;code_1&gt;</code> 进行编译, 否则采用 <code>&lt;code_2&gt;</code>.</p>
<h2 id="3-基本运算及控制流"><a href="#3-基本运算及控制流" class="headerlink" title="3 基本运算及控制流"></a>3 基本运算及控制流</h2><h3 id="基本运算符和优先级"><a href="#基本运算符和优先级" class="headerlink" title="基本运算符和优先级"></a>基本运算符和优先级</h3><p>&emsp;&emsp;具体的可以查表. 粗略来说 (并未列举所有运算符), 优先级顺序为 (所有行中, 越向上优先级越高; 同一行中, 优先级相同):</p>
<ol>
<li>特殊运算符 (括号, 数组索引, 结构体的指向运算符): <code>()</code>, <code>[]</code>, <code>-&gt;</code></li>
<li>逻辑非运算符, 自增运算, 负号运算符: <code>!</code>, <code>++</code>, <code>--</code>, <code>-</code></li>
<li>算数运算符: <ol>
<li><code>*</code>, <code>/</code>, <code>%</code></li>
<li><code>+</code>, <code>-</code></li>
</ol>
</li>
<li>关系运算符: <ol>
<li><code>&lt;, &lt;=, &gt;, &gt;=</code></li>
<li><code>==</code>, <code>!=</code></li>
</ol>
</li>
<li>逻辑运算符:<ol>
<li><code>&amp;&amp;</code></li>
<li><code>||</code></li>
</ol>
</li>
<li>赋值运算符: <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code></li>
</ol>
<p><strong>Notation :</strong></p>
<ol>
<li>自增/减运算符有前缀和后缀两种模式, 其只能与变量结合. 对于前缀模式 <code>++a</code>, 其返回的是变化后的值; 对于后缀模式 <code>a--</code>, 其返回的是变化前的值.</li>
</ol>
<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if-型"><a href="#if-型" class="headerlink" title="if 型"></a><code>if</code> 型</h4><p>&emsp;&emsp;<code>if</code> 型分支的基本语法为:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (&lt;cond_1&gt;)<br>    &lt;sentence_1&gt;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (&lt;cond_2&gt;)<br>    &lt;sentence_2&gt;<br>...<br><span class="hljs-keyword">else</span><br>    &lt;sentence&gt;<br></code></pre></div></td></tr></table></figure>
<p><strong>Notation :</strong></p>
<ol>
<li><code>if</code> 后的判断条件要加括号;</li>
<li>语法上考虑, <code>&lt;sentence&gt;</code> 只能对应单条语句, 因此如果需要进行多个过程, 需要使用复合语句 (亦即将语句段用大括号 <code>&#123;&#125;</code>括起来);</li>
<li>可以使用 <code>break</code> 来跳出分支结构, 直接执行分支结构后面的源代码. 当有多层嵌套时, 仅仅跳出 <code>break</code> 所在层;</li>
</ol>
<h4 id="switch-型"><a href="#switch-型" class="headerlink" title="switch 型"></a><code>switch</code> 型</h4><p>&emsp;&emsp;<code>switch</code> 型通过值是否匹配来判断选择哪一个分支:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (&lt;var&gt;) &#123;<br>    <span class="hljs-keyword">case</span> &lt;expr_1&gt;:<br>        &lt;sentence_1&gt;;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> &lt;expr_2&gt;:<br>        &lt;sentence_2&gt;;<br>        <span class="hljs-keyword">break</span>;<br>...<br>    <span class="hljs-keyword">default</span>:<br>        &lt;sentence&gt;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这里如果 <code>&lt;var&gt;</code> 的值与某一个 <code>&lt;sentence&gt;</code> 相等, 则执行该分支, 执行完成后继续向下走, 直到遇到 <code>break</code> 或右侧的大括号才跳出 <code>switch</code> 语句块.</p>
<p><strong>Notation :</strong></p>
<ol>
<li><code>switch</code> 后面的语句块要加上大括号;</li>
<li>各个分支 <code>case</code> 的条件不需要加加号, 但在 <code>&lt;expr&gt;</code> 后面应加上冒号;</li>
<li>每条 <code>case</code> 对应的分支语句可以是多条语句, 不需要使用花括号将各个语句括起来;</li>
<li><code>default</code> 分支不是必要的, 正如其名一样, 意义是提供一个默认值. 具体来说, 其作用是只要程序运行到 <code>default</code>, 则该分支必定执行;</li>
<li>上面代码中的 <code>break</code> 并不是必要的, 其作用是确保执行完某条分支后不再判断后面的分支. 若不使用 <code>break</code>, 可能在执行了第 $i$ 条分支以后, 还执行 <code>default</code> 的内容, 因此一般建议加上 <code>default</code>;</li>
</ol>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while-型"><a href="#while-型" class="headerlink" title="while 型"></a><code>while</code> 型</h4><p>&emsp;&emsp;<code>while</code> 型循环的基本结构是:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (&lt;cond&gt;)<br>    &lt;sentence&gt;<br></code></pre></div></td></tr></table></figure>
<p>其作用是当条件 <code>cond</code> 为真时执行 <code>&lt;sentence&gt;</code> (第一次执行前要先进行判断), 直到条件为假则跳出循环.</p>
<p><strong>Notation :</strong></p>
<ol>
<li><code>&lt;sentence&gt;</code> 语法上规定为单条语句, 因此需要多个处理过程时应使用复合语句作为 <code>while</code> 的循环体;</li>
</ol>
<h4 id="do-while-型"><a href="#do-while-型" class="headerlink" title="do-while 型"></a><code>do-while</code> 型</h4><p>&emsp;&emsp;<code>do-while</code> 型循环的基本结构是:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">do</span><br>    &lt;sentence&gt;<br><span class="hljs-keyword">while</span>(&lt;cond&gt;);<br></code></pre></div></td></tr></table></figure>
<p>与 <code>while</code> 语句不同的是, 这里是先执行循环体再进行判断.</p>
<p><strong>Notation :</strong></p>
<ol>
<li>最后一行的 <code>while(&lt;cond&gt;);</code> 末尾处别忘了加分号 <code>;</code>;</li>
<li><code>sentence</code> 逻辑上是单条语句;</li>
</ol>
<h4 id="for-型"><a href="#for-型" class="headerlink" title="for 型"></a><code>for</code> 型</h4><p>&emsp;&emsp;<code>for</code> 型循环的基本结构是:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (&lt;expr_1&gt;; &lt;expr_2&gt;; &lt;expr_3&gt;)<br>    &lt;sentence&gt;<br></code></pre></div></td></tr></table></figure>
<p>在循环开始前会先执行 <code>&lt;expr_1&gt;</code> (通常用来进行变量初始化), 使用判断条件 <code>expr_2</code> 进行判断. 若条件为真, 便执行循环体 <code>&lt;sentence&gt;</code>, 再执行 <code>&lt;expr_3&gt;</code> 完成一次循环.</p>
<p><strong>Notation :</strong></p>
<ol>
<li><code>&lt;sentence&gt;</code> 逻辑上是单条语句;</li>
</ol>
<h2 id="4-数组和字符串"><a href="#4-数组和字符串" class="headerlink" title="4 数组和字符串"></a>4 数组和字符串</h2><h3 id="数组的定义及元素引用"><a href="#数组的定义及元素引用" class="headerlink" title="数组的定义及元素引用"></a>数组的定义及元素引用</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><p>&emsp;&emsp;一维数组的定义方式为:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">&lt;type&gt; &lt;var_name&gt;[&lt;len&gt;];<br></code></pre></div></td></tr></table></figure>
<p>如:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> x[<span class="hljs-number">10</span>];<br></code></pre></div></td></tr></table></figure>
<p>定义了一个 1 维数组, 其含有 10 个元素, 每个元素为一个整数.</p>
<p>&emsp;&emsp;数组可在定义的同时进行初始化, 初始化的诸值放在花括号内, 用逗号分隔. 如:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> x[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>在初始化时也可不显式写出数组的长度. 下面的语句与上面的是等价的:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> x[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>如果后面的元素数目小于数组长度, 则相当于进行了部分的初始化, 如:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">double</span> x[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">3.0</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>此时数组的最后一个元素没有初始化. 根据情况的不同, 可能会进行自动初始化 (一般自动初始化会将其设为 0) 或保留内存中原有的值.</p>
<p>&emsp;&emsp;数组的索引可以通过中括号来进行, 注意索引是从 0 开始的, 如:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> x[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, x[<span class="hljs-number">0</span>]);<br></code></pre></div></td></tr></table></figure>
<p>输出结果将为 <code>1</code>.</p>
<p><strong>Notation :</strong></p>
<ol>
<li><p><code>sizeof</code> 作用与数组后得到的是数组所占存储区域的字节数, 而非数组长度. 对于代码:</p>
 <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> x[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lu\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(x));<br></code></pre></div></td></tr></table></figure>
<p> 其得到的结果是 <code>40</code>, 这是由于每个整数占用了 4 个字节, 而一共有 10 个整数.</p>
</li>
</ol>
<h4 id="二维及多维数组"><a href="#二维及多维数组" class="headerlink" title="二维及多维数组"></a>二维及多维数组</h4><p>&emsp;&emsp;这里仅介绍二维数组, 多维数组的情况同理.</p>
<p>&emsp;&emsp;二维数组的定义与一维数组类似, 差别在于要指定两个长度:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">&lt;type&gt; &lt;var_name&gt;[&lt;len_1&gt;][&lt;len_2&gt;];<br></code></pre></div></td></tr></table></figure>
<p>二维数组在内存中排列时是从右往左线性排列的, 亦即先将第二指标填满. 若数组的原型为:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> x[<span class="hljs-number">10</span>][<span class="hljs-number">4</span>]<br></code></pre></div></td></tr></table></figure>
<p>则 <code>x[3][3]</code> 是其第 $3 \times 4 + 3 = 15$ 个元素.</p>
<p>&emsp;&emsp;与一维数组类似, 可以通过大括号对数组进行初始化:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;&#125;;<br></code></pre></div></td></tr></table></figure>
<p>也可以仅指定第二维的长度:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;&#125;;<br></code></pre></div></td></tr></table></figure>
<p>甚至连中间的大括号都可以省略:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a[][<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>&emsp;&emsp;在进行索引时与一维数组类似, 都是形如 <code>a[4][3]</code>.</p>
<h3 id="字符串与数组的关系"><a href="#字符串与数组的关系" class="headerlink" title="字符串与数组的关系"></a>字符串与数组的关系</h3><p>&emsp;&emsp;字符串本质上是一个以字符数组, 特别地, 其始终以 <code>\0</code> 结尾, 因此实际的字符数是数组长度减去 1. 以下 <code>a</code> 与 <code>b</code> 是等价的:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> a[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">char</span> b[] = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<h2 id="5-指针"><a href="#5-指针" class="headerlink" title="5 指针"></a>5 指针</h2><h3 id="指针及变量地址"><a href="#指针及变量地址" class="headerlink" title="指针及变量地址"></a>指针及变量地址</h3><p>&emsp;&emsp;指针与普通变量定义时的区别是多了一个星号 <code>*</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">&lt;type&gt; * &lt;var&gt;;<br></code></pre></div></td></tr></table></figure>
<p>如:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *p;<br></code></pre></div></td></tr></table></figure>
<p>定义了一个 <code>char</code> 类型的指针.</p>
<p>&emsp;&emsp;可以用变量的地址给指针赋值, 与号 <code>&amp;</code> 在 C 语言中是取地址符, 赋值时保持指针变量与取地址变量类型的一致性. 如:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> x = <span class="hljs-string">&#x27;t&#x27;</span>;<br><span class="hljs-keyword">char</span> *p = &amp;x;<br></code></pre></div></td></tr></table></figure>
<p>对指针作用星号 <code>*</code> 后将会得到指针所指向的数据. 对上面的程序, 后面的源代码中的 <code>*p</code> 与 <code>x</code> 是等价的.</p>
<h3 id="指针与数组的关系"><a href="#指针与数组的关系" class="headerlink" title="指针与数组的关系"></a>指针与数组的关系</h3><p>&emsp;&emsp;在引入指针及数据的地址的概念后, 可以对数组的字面意做全新的理解, 下面将分一维与二维 (多维) 数组进行讨论. 再讨论的随后, 还将在数组的基础上介绍指针的运算的概念.</p>
<h4 id="一维数组-1"><a href="#一维数组-1" class="headerlink" title="一维数组"></a>一维数组</h4><p>&emsp;&emsp;对一维数组 <code>a</code>, 数组名本身的字面意其实是数组的起始地址, 如:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> x[] = <span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-keyword">char</span> *p = x;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, *p);<br></code></pre></div></td></tr></table></figure>
<p>将返回 <code>t</code>.</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>&emsp;&emsp;对二维数组 <code>a</code>, 以下写法均表示首元素 <code>a[0][0]</code> 的起始地址:</p>
<ol>
<li>首元素加取地址符: <code>&amp;a[0][0]</code>;</li>
<li>第一个指标的 0 号元素: <code>a[0]</code>;</li>
<li>数组名取指针运算: <code>*a</code>;</li>
</ol>
<h4 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h4><p>&emsp;&emsp;设 <code>p</code> 是一个指针变量, 则可以将其加上一个整数, 来代表将指针进行移动. 讨论一个不指向数组 (确切的来说应该是指向数组特定元素) 的指针的移动意义不大, 所以这里是在数组的基础上讨论的.</p>
<p>&emsp;&emsp;为了简洁起见, 这里直接通过等价性的举例来理解指针的运算. 先考虑最简单的一维数组的情景. 若有 (这里用到了一维数组的字面量代表其首地址的特性):</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> x[] = <span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-keyword">char</span> *p = x;<br></code></pre></div></td></tr></table></figure>
<p>则后面的代码中使用 <code>*p</code> 时, 其实相当于使用 <code>x[0]</code>; 使用 <code>*(p + 1)</code> 时, 相当于使用 <code>x[1]</code>. 特别地, 若指向的不是数组的首地址, 则指针减去一个整数是有意义的:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> x[] = <span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-keyword">char</span> *p = &amp;x[<span class="hljs-number">2</span>];<br></code></pre></div></td></tr></table></figure>
<p>后面的代码中使用 <code>*(p - 1)</code> 时相当于使用的是 <code>x[1]</code>.</p>
<p>&emsp;&emsp;下面再看多维数组. 可知, 多维数组在内存中的排列是线性的, 因此指针运算后先是在线性地址上进行分析, 随后再转化到多维数组的各个维数上去. 具体而言, 若:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> x[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br><span class="hljs-keyword">char</span> *p = x[];<br></code></pre></div></td></tr></table></figure>
<p>则 <code>*(p + 10*3 + 2)</code> 与 <code>x[3][2]</code> 代表的是同一个元素.</p>
<h3 id="指针数组与命令行参数"><a href="#指针数组与命令行参数" class="headerlink" title="指针数组与命令行参数"></a>指针数组与命令行参数</h3><p>&emsp;&emsp;为了使编译的二进制文件可以像正常的命令行工具一样接受参数, 需要使主函数定义两个参数, 一般的形式为:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>第一个参数接受的是输入参数的个数; 后面是一个指针数组 (亦即 <code>argv</code> 的每一个元素都是一个指针), 其指向的是输入的参数 (输入的参数是一个个的字符串).</p>
<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h3><p>&emsp;&emsp;函数定义的基本要素有: 函数的返回类型, 函数的名称, 函数的参数及参数类型, 函数的执行语句. 定义函数的语法为:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">&lt;type&gt; &lt;fun_name&gt;(&lt;tp_1&gt; &lt;var_1&gt;, &lt;tp_2&gt; &lt;var_2&gt;) &#123;<br>    &lt;sentence&gt;;<br>    <span class="hljs-keyword">return</span> &lt;expr&gt;;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>其中 <code>return</code> 关键字用来返回数据, 但函数类型为 <code>void</code> 时则无需 <code>return</code>.</p>
<p>&emsp;&emsp;在调用函数前需要进行声明, 其下面两种声明方式均可:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">&lt;type&gt; &lt;fun_name&gt;(&lt;tp_1&gt; &lt;var_1&gt;, &lt;tp_2&gt; &lt;var_2&gt;)<br>&lt;type&gt; &lt;fun_name&gt;(&lt;tp_1&gt;, &lt;tp_2&gt;)<br></code></pre></div></td></tr></table></figure>
<p>亦即声明时可以不指定形参的符号, 而只指定其类型. 特别地, 若函数定义的程序段放在主函数之前, 则无需进行声明即可在主函数中进行调用.</p>
<p>&emsp;&emsp;应注意, 函数参数传递的默认方式是值传递. 因此若想使用传入的变量本身 (常用于对传入变量进行操纵的场合), 则应当将指针作为形参, 传入时也应传入变量的地址.</p>
<h3 id="变量的生存期与作用域"><a href="#变量的生存期与作用域" class="headerlink" title="变量的生存期与作用域"></a>变量的生存期与作用域</h3><p>&emsp;&emsp;在这里并不打算具体讲解关于变量的生存期与作用域的具体细节, 而只给出一些关键的点 (部分叙述可能不那么严谨).</p>
<p>&emsp;&emsp;粗略来说, 作为生存期是指变量在程序运行过程中存在的时间; 作用域则是一个变量在源程序中的有效范围. 对于生存期及作用域, 值得关注的点有:</p>
<ol>
<li>定义在主函数外 (包括以及任何函数定义以外) 的变量称为全局变量, 其可在整个程序中调用;</li>
<li>定义在主函数以内的变量为局部变量, 若有全局变量与之同名, 则调用时优先使用局部变量, 这可称为 “就近原则”;</li>
<li>函数中的变量一般是临时变量, 仅在函数调用时存在. 但变量定义前加上关键字 <code>static</code> 则可将其生存期拓展到整个程序运行过程中, 但作用域不变;</li>
<li>若有全局变量定义在源文件靠后位置, 可在其前面使用 <code>extern</code> 关键字拓展其作用域, 使之可以在 <code>extern</code> 声明后的源代码范围内使用;</li>
</ol>
<h3 id="使用指向函数的指针"><a href="#使用指向函数的指针" class="headerlink" title="使用指向函数的指针"></a>使用指向函数的指针</h3><p>&emsp;&emsp;指向函数的指针的定义方式为:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">&lt;type&gt; (*&lt;pointer_name&gt;)(&lt;tp&gt; &lt;var&gt;);<br></code></pre></div></td></tr></table></figure>
<p>如:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">double</span> (*p)(<span class="hljs-keyword">double</span> x)<br></code></pre></div></td></tr></table></figure>
<p>定义了一个指向返回值为 <code>double</code>, 输入值为一个 <code>double</code> 的函数的指针. 设有函数定义:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x*<span class="hljs-number">2.0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>则函数头本身就表示了函数的地址, 于是可以用其对指针赋值 (形如 <code>p = f</code>). 调用时, <code>(*p)</code> 等价于  <code>f</code>. 亦即若 <code>f</code> 按照上面的代码段定义, 则 <code>(*p)(3.0)</code> 返回的结果为 <code>6.0</code> (已省略输出格式的控制语句).</p>
<h2 id="7-结构体和联合体"><a href="#7-结构体和联合体" class="headerlink" title="7 结构体和联合体"></a>7 结构体和联合体</h2><h3 id="结构体的定义及别名"><a href="#结构体的定义及别名" class="headerlink" title="结构体的定义及别名"></a>结构体的定义及别名</h3><p>&emsp;&emsp;结构体的定义方法是:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &lt;</span>struct_name&gt; &#123;<br>    &lt;type_1&gt; &lt;var_1&gt;;<br>    &lt;type_2&gt; &lt;var_2&gt;;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>定义好后的结构体可以像通常的类型关键字一样用来定义变量.<br>&emsp;&emsp;另一方面, 也可直接定义结构体变量, 亦即:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span>  &#123;</span><br>    &lt;type_1&gt; &lt;var_1&gt;;<br>    &lt;type_2&gt; &lt;var_2&gt;;<br>&#125; &lt;var&gt;;<br></code></pre></div></td></tr></table></figure>
<p>&emsp;&emsp;使用 <code>typeof</code> 关键字可以给结构体定一个别名:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">typeof &lt;structure&gt; &lt;alias&gt;;<br></code></pre></div></td></tr></table></figure>
<h3 id="结构体的使用"><a href="#结构体的使用" class="headerlink" title="结构体的使用"></a>结构体的使用</h3><p>&emsp;&emsp;可以通过点运算符 <code>.</code> 来获取结构体的成员. 在进行初始化时, 可以使用类似于数组的方式, 亦即大括号将各量括起来, 并用逗号分隔.</p>
<p>&emsp;&emsp;值得注意的是, 结构体整体无法进行输入或输出, 只能分别输入或输出结构体的每个成员.</p>
<p>&emsp;&emsp;另一方面, 在结构体也可像通常的数据类型一样, 作为函数的形参或返回值.</p>
<h3 id="结构体数据类型和指针的关系"><a href="#结构体数据类型和指针的关系" class="headerlink" title="结构体数据类型和指针的关系"></a>结构体数据类型和指针的关系</h3><p>&emsp;&emsp;结构体类型变量的指针就是该结构体类型变量所占内存区域的起始地址, 定义方法与一般变量相同. 值得一提的是, 若想从结构体指针获取结构体成员, 需要先用 <code>*</code> 取结构体, 再用 <code>.</code> 取成员, 未免有些繁琐. 为此, C 语言提供了指向运算符 <code>-&gt;</code> 以简化这种操作. 设 <code>ptr</code> 是一个指向结构体的变量, <code>name</code> 为结构体的一个成员, 则 <code>(*ptr).name</code> 与 <code>ptr-&gt;name</code> 是等价的.</p>
<h3 id="联合体数据类型"><a href="#联合体数据类型" class="headerlink" title="联合体数据类型"></a>联合体数据类型</h3><p>&emsp;&emsp;联合体的定义方式和调用方式与结构体类似. 定义方式是:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> &lt;</span>struct_name&gt; &#123;<br>    &lt;type_1&gt; &lt;var_1&gt;;<br>    &lt;type_2&gt; &lt;var_2&gt;;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>调用时也可使用点操作符 <code>.</code> 或通过将地址赋给指针, 并使用 <code>-&gt;</code> 来访问成员.</p>
<p>&emsp;&emsp;结构体与联合体最大的不同在于, 其同时只能存在一个成员, 且占用内存为成员中占用内存最大者.</p>
<h2 id="8-C-程序文件处理基础"><a href="#8-C-程序文件处理基础" class="headerlink" title="8 C 程序文件处理基础"></a>8 C 程序文件处理基础</h2><h3 id="文件数据的读写"><a href="#文件数据的读写" class="headerlink" title="文件数据的读写"></a>文件数据的读写</h3><p>&emsp;&emsp;读取文件前受限需要打开文件, C 语言中采用函数 <code>fopen(&lt;file&gt;, &lt;mode&gt;)</code> 来实现, 其返回一个指向文件的指针. 如:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">FILE fpt;<br>fp = fopen(<span class="hljs-string">&quot;temp.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br></code></pre></div></td></tr></table></figure>
<p>后面的 <code>&quot;w&quot;</code> 是表示以写方式打开文件.</p>
<p>&emsp;&emsp;另一个关心的问题是文件是否已经到达文件尾部, 这可通过汇聚 <code>feof(&lt;file_pointer&gt;)</code> 来实现. 这里输入的是一个指向文件的指针, 若该文件已到文件尾部, 则返回 1, 否则返回 0.</p>
<p>&emsp;&emsp;文件读写函数包括:</p>
<ol>
<li><code>int fgetc(FILE *stream)</code>: 将单个字符独处文件, 执行成功则返回相应字符, 遇到文件结束符或出错时返回 EOF (-1);</li>
<li><code>int fputc(FILE *stream)</code>: 将单个字符读入文件;</li>
<li><code>char *fgets(char *s, int n , FILE *stream)</code>: <ol>
<li>从关联文件中最多读取 <code>n-1</code> 各字符, 添加上 <code>\0</code> 后放到 <code>*s</code> 指向的字符串中;</li>
<li>若读取到换行符, 则同样结束读取并添加 <code>\0</code>;</li>
<li>返回对象为 <code>s</code> 对象的首地址;</li>
</ol>
</li>
<li><code>char fputs(const char *s, FILE *stream)</code>: 将 <code>s</code> 所代表的字符串写入关联文件, 正常执行时返回写入文件中的字符个数;</li>
<li><code>int fscanf(FILE *stream, const char *format)</code>: 使用标准化输入读出文件数据;</li>
<li><code>int fprintf(FILE *stream, const char *format)</code>: 使用标准化输出写入文件数据;</li>
</ol>
<h3 id="随机存取文件处理基础"><a href="#随机存取文件处理基础" class="headerlink" title="随机存取文件处理基础"></a>随机存取文件处理基础</h3><p>&emsp;&emsp;随机存取文件处理的目的是将文件指针位置进行查询或移动. 相关函数有:</p>
<ol>
<li><code>void rewind(FILE *stream)</code>: 将文件内部指针指向文件开头;</li>
<li><code>int ,seek(FILE *stream, long offset, int origin)</code>: 将文件指针从起始位置 <code>origin</code> 移动字节量 <code>offset</code>. 其中 <code>origin</code> 一般取 <code>0</code>, <code>1</code>, <code>2</code>, 并有符号常量与之对应, 它们代表的含义为:<ol>
<li><code>SEEK_SET</code>: 0, 文件头;</li>
<li><code>SEEK_CUR</code>: 1, 内部记录指针当前位置;</li>
<li><code>SEEK_END</code>: 2, 文件尾;</li>
</ol>
</li>
<li><code>long ftell(FILE *stream)</code>: 获取文件内部读写指针当前位置;</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/CS-Program-Language/">CS Program Language</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CS/">CS</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-NC-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/43558/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">球面坐标系中的微分几何及其应用</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/35059/">
                        <span class="hidden-mobile">[READ] Chapter 7 Ordinary Differential Equations</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#valine",
          app_id: "wNYvhmUL76rLW06m5BRtAJMu-MdYXbMMI",
          app_key: "DUXAXpsqA1waDIXf9aqAYegs",
          placeholder: "welcome to discuss!",
          path: window.location.pathname,
          avatar: "mp",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "en",
          highlight: false,
          recordIP: false,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  








  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
